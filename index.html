<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ˜Ÿç³»æ¨¡æ‹Ÿå™¨ - çœŸå®å®‡å®™æ¢ç´¢</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      display: block;
    }
    
    .control-panel {
      backdrop-filter: blur(10px);
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }
    .stats-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(15, 23, 42, 0.7);
      border-radius: 10px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #0f172a, #1e1b4b);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 1s ease-out;
    }
    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }
    .loading-progress {
      height: 100%;
      background: linear-gradient(to right, #4f46e5, #a855f7);
      width: 0%;
      transition: width 0.3s ease;
    }
    .star-pulse {
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 0.7; }
    }
    .galaxy-type-btn.active {
      background: #4f46e5;
      box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
    }
    .ui-hidden .control-panel,
.ui-hidden .stats-panel,
.ui-hidden #showOwnedPanel {
    display: none;
}

#showUI {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.3);
    color: rgba(255, 255, 255, 0.9);
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    opacity: 0;
    transition: opacity 1s ease;
    font-size: 12px;
}
#showUI.visible {
    opacity: 1;
    transition: opacity 0.1s ease;
}
  </style>
</head>
<button id="showUI" style="display:none;">æ˜¾ç¤ºUI</button>
<body class="bg-black text-white">
  <!-- åŠ è½½å±å¹• -->
  <div id="loadingScreen" class="loading-screen" style="background: #000;">
    <div class="text-center">
      <h1 class="text-4xl font-bold mb-4 flex items-center justify-center">
        <span class="mr-3 star-pulse">ğŸŒŒ</span> æ˜Ÿç³»æ¨¡æ‹Ÿå™¨
      </h1>
      <p class="text-lg text-purple-200 mb-6">æ­£åœ¨åˆå§‹åŒ–å®‡å®™ç¯å¢ƒ...</p >
      <div class="loading-bar">
        <div id="loadingProgress" class="loading-progress"></div>
      </div>
    </div>
  </div>

  <!-- ä¸»ç•Œé¢ -->
  <div id="mainContent" class="hidden flex flex-col items-center justify-center h-screen overflow-hidden">
    <div class="control-panel rounded-xl p-4 w-11/12 max-w-5x!">
      <div class="flex flex-wrap items-center justify-between mb-4">
        <h1 class="text-2xl font-bold flex items-center">
          <span class="mr-2">ğŸŒŒ</span> æ˜Ÿç³»æ¨¡æ‹Ÿå™¨
        </h1>
        <div class="flex items-center space-x-4">
          <span id="fpsCounter" class="text-sm bg-purple-900 px-2 py-1 rounded">FPS: 60</span>
          <span id="galaxyCount" class="text-sm bg-blue-900 px-2 py-1 rounded">æ˜Ÿç³»: 2</span>
        </div>
      </div>
      <button id="hideUI" class="text-sm bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded">éšè—UI</button>
      <div class="flex flex-wrap items-center gap-4 mb-3">
        <div class="flex space-x-2">
          <button id="startBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg transition-all flex items-center">
            <span class="mr-2">â–¶ï¸</span> å¼€å§‹
          </button>
          <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded-lg transition-all flex items-center">
            <span class="mr-2">â¸ï¸</span> æš‚åœ
          </button>
          <button id="resetBtn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg transition-all flex items-center">
            <span class="mr-2">ğŸ”„</span> é‡ç½®
          </button>
        </div>
        
        <div class="flex items-center">
          <label for="speedSlider" class="mr-2 text-sm">é€Ÿåº¦:</label>
          <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" 
                 class="w-32 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
          <span id="speedValue" class="ml-2 text-sm w-10">1.0x</span>
        </div>
        
        <div class="flex items-center">
          <label for="densitySlider" class="mr-2 text-sm">å¯†åº¦:</label>
          <input type="range" id="densitySlider" min="0.1" max="2" step="0.1" value="1" 
                 class="w-32 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
          <span id="densityValue" class="ml-2 text-sm w-10">1.0x</span>
        </div>
      </div>
      <div class="flex items-center">
  <button id="musicToggle" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded-lg transition-all flex items-center mr-2">
    <span class="mr-2">ğŸµ</span> éŸ³ä¹
  </button>
  <label for="volumeSlider" class="mr-2 text-sm">éŸ³é‡:</label>
  <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.5" 
         class="w-24 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
  <span id="volumeValue" class="ml-2 text-sm w-8">50%</span>
</div>
      
      
      
      <div class="text-xs text-gray-300">
        <strong>æ§åˆ¶è¯´æ˜:</strong> 
        å·¦é”®æ‹–åŠ¨=æ—‹è½¬è§†è§’ | 
        æ»šè½®=ç¼©æ”¾è·ç¦» | 
        WASD=åŸºäºè§†è§’ç§»åŠ¨ | 
        QE=åŸºäºè§†è§’å‡é™ |
        R=é‡ç½®è§†è§’ |
        â¬†ï¸â¬‡ï¸â†”ï¸= æ—‹è½¬è§†è§’ 
      </div>
    </div>
    
    <div id="container" class="w-full h-full rounded-lg overflow-hidden"></div>
    <!-- æ˜Ÿç³»ä¿¡æ¯é¢æ¿ -->
<div id="galaxyInfoPanel" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 bg-opacity-95 p-6 rounded-lg shadow-2xl max-w-md w-full hidden z-50">
  <div class="flex justify-between items-start mb-4">
    <h3 class="text-xl font-bold text-white">æ˜Ÿç³»ä¿¡æ¯</h3>
    <button id="closeInfoPanel" class="text-gray-400 hover:text-white text-2xl">&times;</button>
  </div>
  
  <div class="space-y-4">
    <div id="galaxyBasicInfo" class="text-sm text-gray-300">
      <div>åç§°: <span id="galaxyName">-</span></div>
      <div>ç±»å‹: <span id="galaxyType">-</span></div>
      <div>åŠå¾„: <span id="galaxyRadius">-</span> å…‰å¹´</div>
      <div>è·ç¦»: <span id="galaxyDistance">-</span> å…‰å¹´</div>
    </div>
    
    <div id="galaxyDescription" class="text-gray-200 text-sm leading-relaxed border-t border-gray-700 pt-3">
      <p>ç‚¹å‡»æ˜Ÿç³»æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯...</p >
    </div>
    
    <div id="ownershipInfo" class="border-t border-gray-700 pt-3 hidden">
      <div class="text-green-400 text-sm mb-2">âœ… å·²æ‹¥æœ‰</div>
      <div class="text-xs text-gray-400">æ‰€æœ‰è€…: <span id="ownerName">-</span></div>
    </div>
    
    <div class="flex gap-2 pt-3">
      <button id="purchaseGalaxy" class="flex-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white py-2 px-4 rounded transition-all">
        ğŸª è´­ä¹°æ˜Ÿç³»
      </button>
      <button id="deselectGalaxy" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded transition-colors">
        âœ– å–æ¶ˆé€‰æ‹©
      </button>
    </div>
  </div>
</div>

<!-- é€‰æ‹©é«˜äº®æ•ˆæœ -->
<div id="selectionIndicator" class="fixed pointer-events-none hidden z-40">
  <div class="selection-ring"></div>
</div>

<!-- è´­ä¹°æˆåŠŸæç¤º -->
<div id="purchaseToast" class="fixed top-4 right-4 bg-green-600 text-white p-4 rounded-lg shadow-lg hidden z-50">
  ğŸ‰ è´­ä¹°æˆåŠŸï¼è¿™ä¸ªæ˜Ÿç³»ç°åœ¨å±äºæ‚¨äº†ï¼
</div>

<style>
.selection-ring {
  width: 100px;
  height: 100px;
  border: 3px solid #3b82f6;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}

#galaxyInfoPanel {
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.1);
}
</style>
    <!-- ç»Ÿè®¡é¢æ¿ -->
    <div class="stats-panel hidden md:block">
      <h3 class="text-sm font-bold mb-2 text-purple-300">å®‡å®™ç»Ÿè®¡</h3>
      <div class="space-y-1 text-xs">
        <div>å¯è§æ˜Ÿç³»: <span id="visibleGalaxies">2</span></div>
        <div>æ¸²æŸ“è·ç¦»: <span id="renderDistance">3000</span> å•ä½</div>
        <div>ç›¸æœºä½ç½®: <span id="cameraPos">X:0, Y:0, Z:0</span></div>
        <div>ç›¸æœºæ–¹å‘: <span id="cameraDir">X:0, Y:0, Z:-1</span></div>
      </div>
    </div>
  </div>
<script>
    // å®‡å®™å‚æ•° - æ€§èƒ½ä¼˜åŒ–ç‰ˆ
    const universeParams = {
      galaxyDensity: 0.000001,
      renderDistance: 5000,
      maxVisible: 3000,
      minDistance: 300,
      starCount: 1500,
      dustCount: 600,
      nebulaCount: 30,
      haloCount: 600,
      distanceAttenuation: 0.001,
      densityMultiplier: 1.0,
      galaxyType: 'spiral' // é»˜è®¤æ˜Ÿç³»ç±»å‹
    };

    // åˆ›å»ºåœºæ™¯
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    scene.fog = new THREE.FogExp2(0x0a0a1a, 0.0005);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 10000);
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('container').appendChild(renderer.domElement);

    // å…‰ç…§ç³»ç»Ÿ
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0x00bfff, 0.7);
    directionalLight.position.set(50, 50, 50);
    scene.add(directionalLight);

    // æ·»åŠ ä¸€äº›èƒŒæ™¯æ’æ˜Ÿ
    function createBackgroundStars() {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const radius = 2000 + Math.random() * 8000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3+1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3+2] = radius * Math.cos(phi);
        
        const brightness = 0.2 + Math.random() * 0.5;
        starColors[i3] = brightness;
        starColors[i3+1] = brightness;
        starColors[i3+2] = brightness;
        
        starSizes[i] = 0.1 + Math.random() * 0.5;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.7,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        size: 1.0
      });
      
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      return stars;
    }

    // è‡ªç”±ç§»åŠ¨æ§åˆ¶å™¨
    // è‡ªç”±ç§»åŠ¨æ§åˆ¶å™¨
// è‡ªç”±ç§»åŠ¨æ§åˆ¶å™¨ - å››å…ƒæ•°ç‰ˆæœ¬ï¼ˆå®Œæ•´ä»£ç ï¼‰
// è‡ªç”±ç§»åŠ¨æ§åˆ¶å™¨ - å››å…ƒæ•°ç‰ˆæœ¬ï¼ˆå®Œæ•´ä»£ç ï¼‰
const freeMoveController = {
    keys: {
        KeyW: false,
        KeyA: false,
        KeyS: false,
        KeyD: false,
        KeyQ: false,
        KeyE: false,
        KeyR: false,
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        Digit1: false,
        Digit2: false,
        Digit3: false,
        Digit4: false,
        Digit5: false
    },
    baseMoveSpeed: 5.0,
    currentMoveSpeed: 5.0,
    rotationSpeed: 0.0075,
    
    // ä½¿ç”¨å››å…ƒæ•°æ›¿ä»£æ¬§æ‹‰è§’
    cameraQuaternion: new THREE.Quaternion(),
    cameraDirection: new THREE.Vector3(0, 0, -1),

    // é€Ÿåº¦é¢„è®¾
    speedPresets: {
        1: 1,
        2: 5,
        3: 15,
        4: 50,
        5: 200
    },

    setSpeed(speed) {
        this.currentMoveSpeed = speed;
        this.updateSpeedDisplay();
    },

    updateSpeedDisplay() {
        const speedElement = document.getElementById('cameraSpeedValue');
        if (speedElement) {
            speedElement.textContent = `${this.currentMoveSpeed.toFixed(0)}`;
        }
    },

    init() {
        document.addEventListener('keydown', (e) => {
            if (this.keys.hasOwnProperty(e.code)) {
                this.keys[e.code] = true;
            }

            if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                const speedLevel = parseInt(e.code.replace('Digit', ''));
                const newSpeed = this.speedPresets[speedLevel];
                this.setSpeed(newSpeed);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (this.keys.hasOwnProperty(e.code)) {
                this.keys[e.code] = false;
            }
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.addScaledVector(this.cameraDirection, e.deltaY * 0.1);
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                this.resetCamera();
            }
        });

        // åˆå§‹åŒ–å››å…ƒæ•°
        this.cameraQuaternion.identity();
        this.updateCameraDirection();
    },

    update() {
        this.handleMovement();
        this.handleRotation();
        this.updateCameraInfo();
    },

    handleMovement() {
        const moveDirection = new THREE.Vector3();

        // ä½¿ç”¨å››å…ƒæ•°è®¡ç®—æ­£ç¡®çš„æ–¹å‘å‘é‡
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(this.cameraQuaternion);
        
        const right = new THREE.Vector3(1, 0, 0);
        right.applyQuaternion(this.cameraQuaternion);

        if (this.keys.KeyW) moveDirection.add(forward);
        if (this.keys.KeyS) moveDirection.sub(forward);
        if (this.keys.KeyA) moveDirection.sub(right);
        if (this.keys.KeyD) moveDirection.add(right);
        if (this.keys.KeyQ) moveDirection.y -= 1;
        if (this.keys.KeyE) moveDirection.y += 1;

        moveDirection.normalize();
        camera.position.addScaledVector(moveDirection, this.currentMoveSpeed);
    },

    // ä½¿ç”¨å››å…ƒæ•°å¤„ç†æ—‹è½¬
    handleRotation() {
        let yawDelta = 0;
        let pitchDelta = 0;

        if (this.keys.ArrowLeft) yawDelta += this.rotationSpeed;
        if (this.keys.ArrowRight) yawDelta -= this.rotationSpeed;
        if (this.keys.ArrowUp) pitchDelta += this.rotationSpeed;
        if (this.keys.ArrowDown) pitchDelta -= this.rotationSpeed;

        if (yawDelta !== 0 || pitchDelta !== 0) {
            // ä½¿ç”¨å››å…ƒæ•°è¿›è¡Œæ—‹è½¬
            const yawQuaternion = new THREE.Quaternion();
            const pitchQuaternion = new THREE.Quaternion();
            
            // åèˆªï¼ˆYè½´æ—‹è½¬ï¼‰
            yawQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawDelta);
            
            // ä¿¯ä»°ï¼ˆXè½´æ—‹è½¬ï¼‰- ä½¿ç”¨ç›¸æœºçš„å±€éƒ¨Xè½´
            const cameraRight = new THREE.Vector3(1, 0, 0);
            cameraRight.applyQuaternion(this.cameraQuaternion);
            pitchQuaternion.setFromAxisAngle(cameraRight, pitchDelta);
            
            // ç»„åˆæ—‹è½¬
            this.cameraQuaternion.multiplyQuaternions(yawQuaternion, this.cameraQuaternion);
            this.cameraQuaternion.multiplyQuaternions(pitchQuaternion, this.cameraQuaternion);
            this.cameraQuaternion.normalize();
            
            this.updateCameraDirection();
        }
    },

    updateCameraDirection() {
        // ä»å››å…ƒæ•°è®¡ç®—å‰å‘å‘é‡
        this.cameraDirection.set(0, 0, -1);
        this.cameraDirection.applyQuaternion(this.cameraQuaternion);
        this.cameraDirection.normalize();
        
        // æ›´æ–°ç›¸æœºæœå‘
        camera.quaternion.copy(this.cameraQuaternion);
    },

    updateCameraInfo() {
        document.getElementById('cameraPos').textContent =
            `X:${camera.position.x.toFixed(1)}, Y:${camera.position.y.toFixed(1)}, Z:${camera.position.z.toFixed(1)}`;

        // æ˜¾ç¤ºæ¬§æ‹‰è§’ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
        const euler = new THREE.Euler().setFromQuaternion(this.cameraQuaternion, 'YXZ');
        const yawDeg = (euler.y * 180 / Math.PI).toFixed(1);
        const pitchDeg = (euler.x * 180 / Math.PI).toFixed(1);
        document.getElementById('cameraDir').textContent =
            `åèˆª:${yawDeg}Â° ä¿¯ä»°:${pitchDeg}Â°`;
    },

    resetCamera() {
        camera.position.set(390, 500, 0);
        this.cameraQuaternion.identity();
        this.updateCameraDirection();
    }
};
// æ˜Ÿç³»é€‰æ‹©å’Œç®¡ç†ç³»ç»Ÿ
// æ˜Ÿç³»é€‰æ‹©å’Œç®¡ç†ç³»ç»Ÿ - ä¿®å¤ç‰ˆ
const galaxySelectionSystem = {
  selectedGalaxy: null,
  userOwnedGalaxies: new Map(),
  currentUser: 'anonymous',
  
  init() {
    this.setupEventListeners();
    this.setupRaycaster();
    this.loadUserData();
    console.log('æ˜Ÿç³»é€‰æ‹©ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
  },
  
  setupEventListeners() {
    const canvas = renderer.domElement;
    
    // ä¿®å¤ï¼šä½¿ç”¨ pointerdown äº‹ä»¶ï¼Œæ›´å¯é 
    canvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      this.handleClick(event);
    });
    
    // é¢æ¿æ§åˆ¶
    document.getElementById('closeInfoPanel').addEventListener('click', () => this.hideInfoPanel());
    document.getElementById('deselectGalaxy').addEventListener('click', () => this.deselectGalaxy());
    document.getElementById('purchaseGalaxy').addEventListener('click', () => this.purchaseGalaxy());
    
    // ESCé”®å–æ¶ˆé€‰æ‹©
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        this.deselectGalaxy();
      }
    });
    
    console.log('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
  },
  
  setupRaycaster() {
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    console.log('å°„çº¿æ£€æµ‹å™¨åˆå§‹åŒ–å®Œæˆ');
  },
  
  // ä¿®å¤ç‚¹å‡»å¤„ç†
  handleClick(event) {
    console.log('ç‚¹å‡»äº‹ä»¶è§¦å‘', event);
    
    const rect = renderer.domElement.getBoundingClientRect();
    
    // ä¿®å¤ï¼šæ­£ç¡®çš„åæ ‡è½¬æ¢
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    console.log('é¼ æ ‡åæ ‡:', this.mouse.x, this.mouse.y);
    
    this.raycaster.setFromCamera(this.mouse, camera);
    
    // æ”¶é›†æ‰€æœ‰å¯ç‚¹å‡»çš„å¯¹è±¡
    const clickableObjects = [];
    galaxyManager.galaxies.forEach(galaxy => {
      clickableObjects.push(galaxy.starField);
      if (galaxy.dustField) clickableObjects.push(galaxy.dustField);
      if (galaxy.nebulaField) clickableObjects.push(galaxy.nebulaField);
      if (galaxy.halo) clickableObjects.push(galaxy.halo);
    });
    
    console.log('æ£€æµ‹å¯¹è±¡æ•°é‡:', clickableObjects.length);
    
    // æ‰§è¡Œå°„çº¿æ£€æµ‹
    const intersects = this.raycaster.intersectObjects(clickableObjects, true);
    console.log('äº¤ç‚¹æ•°é‡:', intersects.length);
    
    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;
      console.log('ç‚¹å‡»åˆ°å¯¹è±¡:', clickedObject);
      
      // æ‰¾åˆ°å¯¹åº”çš„æ˜Ÿç³»
      const galaxy = galaxyManager.galaxies.find(g => 
        g.starField === clickedObject || 
        g.dustField === clickedObject ||
        g.nebulaField === clickedObject ||
        g.halo === clickedObject
      );
      
      if (galaxy) {
        console.log('æ‰¾åˆ°æ˜Ÿç³»:', galaxy);
        this.selectGalaxy(galaxy);
      } else {
        console.log('æœªæ‰¾åˆ°å¯¹åº”æ˜Ÿç³»');
      }
    } else {
      console.log('æœªç‚¹å‡»åˆ°ä»»ä½•æ˜Ÿç³»');
      this.deselectGalaxy();
    }
  },
  
  // é€‰æ‹©æ˜Ÿç³»
  selectGalaxy(galaxy) {
    console.log('é€‰æ‹©æ˜Ÿç³»:', galaxy);
    
    // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
    this.deselectGalaxy();
    
    this.selectedGalaxy = galaxy;
    this.showSelectionIndicator(galaxy);
    this.showGalaxyInfo(galaxy);
    
    // æ·»åŠ è§†è§‰åé¦ˆ
    this.highlightGalaxy(galaxy);
  },
  
  // é«˜äº®é€‰ä¸­çš„æ˜Ÿç³»
  highlightGalaxy(galaxy) {
    // ä¸´æ—¶æ”¹å˜é¢œè‰²ä½œä¸ºè§†è§‰åé¦ˆ
    const originalColors = galaxy.starField.geometry.attributes.color.array.slice();
    const colors = galaxy.starField.geometry.attributes.color.array;
    
    // å°†é¢œè‰²è°ƒäº®
    for (let i = 0; i < colors.length; i += 3) {
      colors[i] = Math.min(1.0, colors[i] * 1.3);     // R
      colors[i+1] = Math.min(1.0, colors[i+1] * 1.3); // G
      colors[i+2] = Math.min(1.0, colors[i+2] * 1.3); // B
    }
    
    galaxy.starField.geometry.attributes.color.needsUpdate = true;
    
    // ä¿å­˜åŸå§‹é¢œè‰²ä»¥ä¾¿æ¢å¤
    galaxy.originalColors = originalColors;
  },
  
  // å–æ¶ˆé«˜äº®
  unhighlightGalaxy(galaxy) {
    if (galaxy.originalColors) {
      const colors = galaxy.starField.geometry.attributes.color.array;
      for (let i = 0; i < colors.length; i++) {
        colors[i] = galaxy.originalColors[i];
      }
      galaxy.starField.geometry.attributes.color.needsUpdate = true;
    }
  },
  
  // æ˜¾ç¤ºé€‰æ‹©æŒ‡ç¤ºå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰
  showSelectionIndicator(galaxy) {
    const indicator = document.getElementById('selectionIndicator');
    indicator.classList.remove('hidden');
    
    // ç®€åŒ–ï¼šå°†æŒ‡ç¤ºå™¨æ”¾åœ¨å±å¹•ä¸­å¤®ï¼Œå› ä¸º3Dè½¬2Dåæ ‡å¯èƒ½æœ‰é—®é¢˜
    indicator.style.left = '50%';
    indicator.style.top = '50%';
    indicator.style.transform = 'translate(-50%, -50%)';
    
    console.log('æ˜¾ç¤ºé€‰æ‹©æŒ‡ç¤ºå™¨');
  },
  
  // æ˜¾ç¤ºæ˜Ÿç³»ä¿¡æ¯
  showGalaxyInfo(galaxy) {
    const panel = document.getElementById('galaxyInfoPanel');
    const distance = galaxy.position.distanceTo(camera.position).toFixed(0);
    
    // ç”Ÿæˆéšæœºåç§°
    const galaxyName = this.generateGalaxyName();
    
    // æ›´æ–°åŸºæœ¬ä¿¡æ¯
    document.getElementById('galaxyName').textContent = galaxyName;
    document.getElementById('galaxyType').textContent = this.getGalaxyTypeName(galaxy.type);
    document.getElementById('galaxyRadius').textContent = Math.round(galaxy.params.radius);
    document.getElementById('galaxyDistance').textContent = distance;
    
    // ç”Ÿæˆéšæœºæè¿°
    this.generateGalaxyDescription(galaxy).then(description => {
      document.getElementById('galaxyDescription').innerHTML = description;
    });
    
    // æ£€æŸ¥æ‰€æœ‰æƒ
    this.updateOwnershipInfo(galaxy);
    
    panel.classList.remove('hidden');
    console.log('æ˜¾ç¤ºæ˜Ÿç³»ä¿¡æ¯é¢æ¿');
  },
  
  // ç”Ÿæˆéšæœºæ˜Ÿç³»åç§°
  generateGalaxyName() {
    const prefixes = ['NGC', 'IC', 'UGC', 'ESO', 'MCG', 'ARP'];
    const numbers = ['1234', '4567', '8910', '1121', '3141', '5926', '5358', '9793'];
    const suffixes = ['A', 'B', 'C', '', '-A', '-B'];
    
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const number = numbers[Math.floor(Math.random() * numbers.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    
    return `${prefix} ${number}${suffix}`;
  },
  
  // è·å–æ˜Ÿç³»ç±»å‹åç§°
  getGalaxyTypeName(type) {
    const typeNames = {
      'spiral': 'æ—‹æ¶¡æ˜Ÿç³»',
      'elliptical': 'æ¤­åœ†æ˜Ÿç³»', 
      'irregular': 'ä¸è§„åˆ™æ˜Ÿç³»',
      'collision': 'ç¢°æ’æ˜Ÿç³»'
    };
    return typeNames[type] || type;
  },
  
  // ç”Ÿæˆæ˜Ÿç³»æè¿°
  async generateGalaxyDescription(galaxy) {
    return new Promise((resolve) => {
      setTimeout(() => {
        const descriptions = {
          spiral: [
            `è¿™ä¸ªç¾ä¸½çš„æ—‹æ¶¡æ˜Ÿç³»æ‹¥æœ‰${galaxy.params.arms}æ¡æ¸…æ™°çš„æ—‹è‡‚ï¼Œåœ¨å®‡å®™ä¸­ç¼“æ…¢æ—‹è½¬ã€‚æ ¸å¿ƒåŒºåŸŸèšé›†ç€å¹´è€çš„é»„è‰²æ’æ˜Ÿï¼Œæ—‹è‡‚ä¸­åˆ†å¸ƒç€å¹´è½»çš„è“è‰²æ’æ˜Ÿã€‚`,
            `è¯¥æ—‹æ¶¡æ˜Ÿç³»ç›´å¾„çº¦${Math.round(galaxy.params.radius * 2)}å…‰å¹´ï¼Œæ˜¯å®‡å®™ä¸­æœ€å¸¸è§çš„æ˜Ÿç³»ç±»å‹ä¹‹ä¸€ã€‚`,
            `è§‚æµ‹æ˜¾ç¤ºè¿™ä¸ªæ—‹æ¶¡æ˜Ÿç³»æ­£å¤„äºæ´»è·ƒçš„æ’æ˜Ÿå½¢æˆæœŸï¼Œæ—‹è‡‚ä¸Šçš„æ˜Ÿäº‘åŒºåŸŸæ ‡å¿—ç€æ–°çš„æ’æ˜Ÿæ­£åœ¨è¯ç”Ÿã€‚`
          ],
          elliptical: [
            `è¿™ä¸ªæ¤­åœ†æ˜Ÿç³»å‘ˆç°å‡ºå®Œç¾çš„æ¤­åœ†å½¢çŠ¶ï¼Œä¸»è¦ç”±å¹´è€çš„çº¢è‰²æ’æ˜Ÿç»„æˆã€‚ç¼ºä¹æ°”ä½“å’Œå°˜åŸƒï¼Œæ–°çš„æ’æ˜Ÿå½¢æˆæ´»åŠ¨æœ‰é™ã€‚`,
            `æ¤­åœ†æ˜Ÿç³»é€šå¸¸æ˜¯å®‡å®™ä¸­çš„"è€å¹´"æ˜Ÿç³»ï¼Œå…¶ä¸­çš„æ’æ˜Ÿå¤§å¤šå·²ç»å­˜åœ¨äº†æ•°åäº¿å¹´ã€‚`,
            `è¯¥æ¤­åœ†æ˜Ÿç³»çš„æ’æ˜Ÿåˆ†å¸ƒéå¸¸å‡åŒ€ï¼Œä»æ ¸å¿ƒåˆ°è¾¹ç¼˜å¯†åº¦é€æ¸é™ä½ã€‚`
          ],
          irregular: [
            `è¿™ä¸ªä¸è§„åˆ™æ˜Ÿç³»æ²¡æœ‰æ˜æ˜¾çš„ç»“æ„ç‰¹å¾ï¼Œå½¢çŠ¶æ··æ²Œè€Œç‹¬ç‰¹ã€‚å¯Œå«æ°”ä½“å’Œå°˜åŸƒï¼Œæ­£åœ¨è¿›è¡Œæ´»è·ƒçš„æ’æ˜Ÿå½¢æˆã€‚`,
            `ä¸è§„åˆ™æ˜Ÿç³»å¯èƒ½æ˜¯ç”±äºå¼•åŠ›ç›¸äº’ä½œç”¨è€Œå¤±å»äº†åŸæœ‰çš„ç»“æ„ã€‚å¹´è½»è“è‰²æ’æ˜Ÿç¾¤æ ¼å¤–é†’ç›®ã€‚`,
            `è¯¥ä¸è§„åˆ™æ˜Ÿç³»çš„å¤§å°ç›¸å¯¹è¾ƒå°ï¼Œä½†æ’æ˜Ÿå½¢æˆç‡å´å¾ˆé«˜ã€‚`
          ],
          collision: [
            `è¿™æ˜¯ä¸€å¯¹æ­£åœ¨å‘ç”Ÿç¢°æ’çš„æ˜Ÿç³»ï¼Œå¼•åŠ›ç›¸äº’ä½œç”¨äº§ç”Ÿäº†å£®è§‚çš„æ½®æ±å°¾å’Œæ’æ˜Ÿæµã€‚`,
            `æ˜Ÿç³»ç¢°æ’æ˜¯å®‡å®™ä¸­æœ€å£®è§‚çš„äº‹ä»¶ä¹‹ä¸€ã€‚æ°”ä½“äº‘çš„ç¢°æ’ä¼šè§¦å‘å‰§çƒˆçš„æ’æ˜Ÿå½¢æˆã€‚`,
            `è¿™å¯¹ç¢°æ’æ˜Ÿç³»æœ€ç»ˆå¯èƒ½ä¼šåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„æ¤­åœ†æ˜Ÿç³»ã€‚`
          ]
        };
        
        const typeDescriptions = descriptions[galaxy.type] || descriptions.spiral;
        const randomDescription = typeDescriptions[Math.floor(Math.random() * typeDescriptions.length)];
        
        resolve(`<p>${randomDescription}</p >`);
      }, 100);
    });
  },
  
  // æ›´æ–°æ‰€æœ‰æƒä¿¡æ¯
  updateOwnershipInfo(galaxy) {
    const ownershipInfo = document.getElementById('ownershipInfo');
    const purchaseButton = document.getElementById('purchaseGalaxy');
    
    if (this.userOwnedGalaxies.has(galaxy)) {
      ownershipInfo.classList.remove('hidden');
      purchaseButton.classList.add('hidden');
      document.getElementById('ownerName').textContent = this.currentUser;
    } else {
      ownershipInfo.classList.add('hidden');
      purchaseButton.classList.remove('hidden');
    }
  },
  
  // è´­ä¹°æ˜Ÿç³»
  purchaseGalaxy() {
    if (!this.selectedGalaxy) return;
    
    this.userOwnedGalaxies.set(this.selectedGalaxy, {
      purchaseDate: new Date(),
      purchasePrice: this.calculateGalaxyPrice(this.selectedGalaxy),
      user: this.currentUser
    });
    
    this.saveUserData();
    this.showPurchaseSuccess();
    this.updateOwnershipInfo(this.selectedGalaxy);
    
    console.log(`ç”¨æˆ· ${this.currentUser} è´­ä¹°äº†æ˜Ÿç³»`);
  },
  
  // è®¡ç®—æ˜Ÿç³»ä»·æ ¼
  calculateGalaxyPrice(galaxy) {
    const basePrice = 100;
    const sizeMultiplier = galaxy.params.radius / 50;
    const typeMultiplier = {
      'spiral': 1.5,
      'elliptical': 1.2,
      'irregular': 1.0,
      'collision': 2.0
    }[galaxy.type] || 1.0;
    
    return Math.round(basePrice * sizeMultiplier * typeMultiplier);
  },
  
  // æ˜¾ç¤ºè´­ä¹°æˆåŠŸæç¤º
  showPurchaseSuccess() {
    const toast = document.getElementById('purchaseToast');
    toast.classList.remove('hidden');
    
    setTimeout(() => {
      toast.classList.add('hidden');
    }, 3000);
  },
  
  // å–æ¶ˆé€‰æ‹©
  deselectGalaxy() {
    if (this.selectedGalaxy) {
      this.unhighlightGalaxy(this.selectedGalaxy);
    }
    
    this.selectedGalaxy = null;
    
    document.getElementById('selectionIndicator').classList.add('hidden');
    document.getElementById('galaxyInfoPanel').classList.add('hidden');
    
    console.log('å–æ¶ˆé€‰æ‹©æ˜Ÿç³»');
  },
  
  // éšè—ä¿¡æ¯é¢æ¿
  hideInfoPanel() {
    document.getElementById('galaxyInfoPanel').classList.add('hidden');
  },
  
  // åŠ è½½ç”¨æˆ·æ•°æ®
  loadUserData() {
    const savedData = localStorage.getItem('userGalaxies');
    if (savedData) {
      console.log('åŠ è½½ç”¨æˆ·æ˜Ÿç³»æ•°æ®:', savedData);
    }
  },
  
  // ä¿å­˜ç”¨æˆ·æ•°æ®
  saveUserData() {
    localStorage.setItem('userGalaxies', JSON.stringify({
      user: this.currentUser,
      ownedCount: this.userOwnedGalaxies.size
    }));
  },
  
  // æ¯å¸§æ›´æ–°
  update() {
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ¯å¸§æ›´æ–°çš„é€»è¾‘
  }
};
// æ˜Ÿç³»ç®¡ç†ç³»ç»Ÿ
    const galaxyManager = {
      galaxies: [],
      lastUpdate: 0,
      updateInterval: 100,
      
      init() {
  // åˆ›å»ºåˆå§‹æ˜Ÿç³»ç¾¤ï¼ŒæŒ‰çœŸå®æ¯”ä¾‹åˆ†å¸ƒ
  const galaxyPositions = [
    new THREE.Vector3(0, 0, 0),      // ä¸­å¿ƒæ—‹æ¶¡æ˜Ÿç³»
    new THREE.Vector3(400, 0, 200),  // æ—‹æ¶¡æ˜Ÿç³»
    new THREE.Vector3(-300, 0, -150), // æ—‹æ¶¡æ˜Ÿç³»
    new THREE.Vector3(200, 0, -300),  // æ¤­åœ†æ˜Ÿç³»
    new THREE.Vector3(-200, 0, 350),  // æ¤­åœ†æ˜Ÿç³»
    new THREE.Vector3(500, 0, -100),  // ä¸è§„åˆ™æ˜Ÿç³»
    new THREE.Vector3(-100, 0, 500)   // ç¢°æ’æ˜Ÿç³»ï¼ˆç¨€æœ‰ï¼‰
  ];
  
  const galaxyTypes = ['spiral', 'spiral', 'spiral', 'elliptical', 'elliptical', 'irregular', 'collision'];
  
  galaxyPositions.forEach((position, index) => {
    const type = galaxyTypes[index];
    let galaxy;
    
    switch(type) {
      case 'elliptical':
        galaxy = this.createEllipticalGalaxy({
          position: position,
          radius: 40 + Math.random() * 20,
          rotationSpeed: 0.0008 + Math.random() * 0.0004,
          rotationAngle: Math.random() * Math.PI * 2
        });
        break;
      case 'irregular':
        galaxy = this.createIrregularGalaxy({
          position: position,
          radius: 30 + Math.random() * 15,
          rotationSpeed: 0.001 + Math.random() * 0.0005,
          rotationAngle: Math.random() * Math.PI * 2
        });
        break;
      case 'collision':
        galaxy = this.createCollidingGalaxy({
          position: position,
          radius: 50 + Math.random() * 20,
          arms: 3,
          armTwist: 0.15,
          rotationSpeed: 0.0012 + Math.random() * 0.0003,
          rotationAngle: Math.random() * Math.PI * 2
        });
        break;
      default: // spiral
        galaxy = this.createSpiralGalaxy({
          position: position,
          radius: 45 + Math.random() * 25,
          arms: 2 + Math.floor(Math.random() * 3), // 2-4æ¡æ—‹è‡‚
          armTwist: 0.15 + Math.random() * 0.1,
          rotationSpeed: 0.0015 + Math.random() * 0.0005,
          rotationAngle: Math.random() * Math.PI * 2
        });
    }
    
    this.galaxies.push(galaxy);
    
    // æ·»åŠ åˆ°åœºæ™¯
    scene.add(galaxy.starField);
    scene.add(galaxy.dustField);
    scene.add(galaxy.nebulaField);
    scene.add(galaxy.halo);
    
    // å¦‚æœæ˜¯ç¢°æ’æ˜Ÿç³»ï¼Œæ·»åŠ ç¬¬äºŒä¸ªæ˜Ÿç³»
    if (galaxy.type === 'collision' && galaxy.galaxy2) {
      scene.add(galaxy.galaxy2.starField);
      scene.add(galaxy.galaxy2.dustField);
      scene.add(galaxy.galaxy2.nebulaField);
      scene.add(galaxy.galaxy2.halo);
      scene.add(galaxy.bridgeField);
    }
  });
},
      
      createGalaxyByType(params) {
  // ç¡®ä¿æœ‰éšæœºä¸‰ç»´æœå‘
  if (!params.orientation) {
    const randomEuler = new THREE.Euler(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,  
      Math.random() * Math.PI * 2
    );
    params.orientation = new THREE.Quaternion().setFromEuler(randomEuler);
  }
  
  switch(params.type) {
    case 'elliptical':
      return this.createEllipticalGalaxy(params);
    case 'irregular':
      return this.createIrregularGalaxy(params);
    case 'collision':
      return this.createCollidingGalaxy(params);
    default:
      return this.createSpiralGalaxy(params);
  }
},
      
      // åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³»
      // åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³»
// åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³»
// åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³»
// åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³» - ä¿®å¤ç‰ˆ
createSpiralGalaxy(params) {
  console.log('åˆ›å»ºæ—‹æ¶¡æ˜Ÿç³»ï¼Œä½¿ç”¨ä¸‰ç»´éšæœºæœå‘');

  const stars = [];
  const starGeometry = new THREE.BufferGeometry();
  const starCount = universeParams.starCount;
  const starPositions = new Float32Array(starCount * 3);
  const starColors = new Float32Array(starCount * 3);
  const starSizes = new Float32Array(starCount);
  const starTypes = new Uint8Array(starCount);

  // åˆ›å»ºæ—‹è½¬çŸ©é˜µ
  const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(params.orientation);

  for (let i = 0; i < starCount; i++) {
    const i3 = i * 3;
    const typeProb = Math.random();

    // åˆ›å»ºå±€éƒ¨åæ ‡ï¼ˆåœ¨XYå¹³é¢å†…ï¼‰
    let localPosition = new THREE.Vector3();
    
    if (typeProb < 0.1) {
      // æ ¸å¿ƒæ’æ˜Ÿ
      starTypes[i] = 0;
      const radius = Math.random() * params.radius * 0.1;
      const angle = Math.random() * Math.PI * 2;
      
      localPosition.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        (Math.random() - 0.5) * params.radius * 0.03
      );
      
      starColors[i3] = 0.9 + Math.random() * 0.1;
      starColors[i3+1] = 0.8 + Math.random() * 0.1;
      starColors[i3+2] = 0.3 + Math.random() * 0.1;
      starSizes[i] = 0.2 + Math.random() * 0.3;
    } 
    else if (typeProb < 0.7) {
      // æ—‹è‡‚æ’æ˜Ÿ
      starTypes[i] = 1;
      const arm = Math.floor(Math.random() * params.arms);
      const distance = Math.random() * params.radius * 0.8;
      
      const baseArmAngle = arm * (Math.PI * 2 / params.arms);
      const twistAngle = distance * params.armTwist;
      const randomOffset = Math.random() * 0.2;
      const angle = baseArmAngle + twistAngle + randomOffset;
      
      const offset = (Math.random() - 0.5) * params.radius * 0.05;
      
      localPosition.set(
        Math.cos(angle) * (distance + offset),
        Math.sin(angle) * (distance + offset),
        (Math.random() - 0.5) * params.radius * 0.01
      );
      
      const colorFactor = 0.5 + (distance / params.radius) * 0.5;
      starColors[i3] = 0.2 + colorFactor * 0.3;
      starColors[i3+1] = 0.4 + colorFactor * 0.3;
      starColors[i3+2] = 0.8 + colorFactor * 0.1;
      starSizes[i] = 0.05 + Math.random() * 0.15;
    } 
    else if (typeProb < 0.95) {
      // å…‰æ™•æ’æ˜Ÿ
      starTypes[i] = 2;
      const radius = Math.random() * params.radius;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      
      localPosition.set(
        radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.sin(phi) * Math.sin(theta),
        radius * Math.cos(phi)
      );
      
      starColors[i3] = 0.6 + Math.random() * 0.1;
      starColors[i3+1] = 0.2 + Math.random() * 0.1;
      starColors[i3+2] = 0.1 + Math.random() * 0.05;
      starSizes[i] = 0.03 + Math.random() * 0.07;
    } else {
      // çƒçŠ¶æ˜Ÿå›¢æ’æ˜Ÿ
      starTypes[i] = 3;
      const clusterRadius = Math.random() * 2 + 0.5;
      const clusterDistance = Math.random() * (params.radius * 0.9) + params.radius * 0.1;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      const clusterCenter = new THREE.Vector3(
        clusterDistance * Math.sin(phi) * Math.cos(theta),
        clusterDistance * Math.sin(phi) * Math.sin(theta),
        clusterDistance * Math.cos(phi)
      );

      const starTheta = Math.random() * Math.PI * 2;
      const starPhi = Math.acos(2 * Math.random() - 1);
      const starRadius = Math.random() * clusterRadius;

      localPosition.set(
        clusterCenter.x + starRadius * Math.sin(starPhi) * Math.cos(starTheta),
        clusterCenter.y + starRadius * Math.sin(starPhi) * Math.sin(starTheta),
        clusterCenter.z + starRadius * Math.cos(starPhi)
      );

      starColors[i3] = 0.7 + Math.random() * 0.1;
      starColors[i3+1] = 0.3 + Math.random() * 0.1;
      starColors[i3+2] = 0.1 + Math.random() * 0.05;
      starSizes[i] = 0.04 + Math.random() * 0.06;
    }

    // åº”ç”¨ä¸‰ç»´æ—‹è½¬
    localPosition.applyMatrix4(rotationMatrix);
    
    // ç§»åŠ¨åˆ°ä¸–ç•Œä½ç½®
    starPositions[i3] = localPosition.x + params.position.x;
    starPositions[i3+1] = localPosition.y + params.position.y;
    starPositions[i3+2] = localPosition.z + params.position.z;

    stars.push({
      position: new THREE.Vector3(starPositions[i3], starPositions[i3+1], starPositions[i3+2]),
      localPosition: localPosition.clone(),
      distance: localPosition.length(),
      type: starTypes[i],
      home: params.position,
      orientation: params.orientation
    });
  }

  starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
  starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
  starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

  const starMaterial = new THREE.PointsMaterial({
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    sizeAttenuation: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    size: 0.5
  });

  const starField = new THREE.Points(starGeometry, starMaterial);

  // å…¶ä»–ç»„ä»¶ä¹Ÿä½¿ç”¨ç›¸åŒçš„æœå‘
  const dustField = this.createDustCloud({...params});
  const nebulaField = this.createNebula({...params});
  const halo = this.createHalo({...params});

  return {
    position: params.position,
    starField,
    dustField,
    nebulaField,
    halo,
    stars,
    params: {...params},
    type: 'spiral'
  };
},
      
      // åˆ›å»ºæ¤­åœ†æ˜Ÿç³»
      createEllipticalGalaxy(params) {
        const stars = [];
        const starGeometry = new THREE.BufferGeometry();
        const starCount = universeParams.starCount;
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);

        const galaxyRotation = params.rotationAngle || 0;

        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          
          // æ¤­åœ†åˆ†å¸ƒ
          const radius = Math.pow(Math.random(), 0.5) * params.radius;
          const theta = Math.random() * Math.PI * 2 + galaxyRotation;
          const phi = Math.acos(2 * Math.random() - 1);
          
          // æ¤­åœ†å½¢çŠ¶ - åœ¨Zè½´æ–¹å‘å‹ç¼©
          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi) * 0.3; // å‹ç¼©Zè½´

          starPositions[i3] = x + params.position.x;
          starPositions[i3+1] = y + params.position.y;
          starPositions[i3+2] = z + params.position.z;

          // æ¤­åœ†æ˜Ÿç³»é€šå¸¸æ›´çº¢/é»„
          const colorFactor = 0.3 + Math.random() * 0.4;
          starColors[i3] = 0.8 + colorFactor * 0.2;
          starColors[i3+1] = 0.6 + colorFactor * 0.2;
          starColors[i3+2] = 0.2 + colorFactor * 0.2;

          starSizes[i] = 0.05 + Math.random() * 0.15;

          stars.push({
            position: new THREE.Vector3(starPositions[i3], starPositions[i3+1], starPositions[i3+2]),
            distance: Math.sqrt(x*x + y*y),
            home: params.position,
            rotationAngle: galaxyRotation
          });
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 0.5
        });

        const starField = new THREE.Points(starGeometry, starMaterial);

        // æ¤­åœ†æ˜Ÿç³»å°˜åŸƒè¾ƒå°‘
        const dustField = this.createDustCloud({...params, count: universeParams.dustCount * 0.5});
        const nebulaField = this.createNebula({...params, count: universeParams.nebulaCount * 0.3});
        const halo = this.createHalo({...params, count: universeParams.haloCount * 0.7});

        return {
          position: params.position,
  starField,
  dustField,
  nebulaField,
  halo,
  stars,
  params,
  type: 'elliptical'

        };
      },
      
      // åˆ›å»ºä¸è§„åˆ™æ˜Ÿç³»
      createIrregularGalaxy(params) {
        const stars = [];
        const starGeometry = new THREE.BufferGeometry();
        const starCount = universeParams.starCount;
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);

        const galaxyRotation = params.rotationAngle || 0;

        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          
          // ä¸è§„åˆ™åˆ†å¸ƒ
          const radius = Math.random() * params.radius;
          const theta = Math.random() * Math.PI * 2 + galaxyRotation;
          const phi = Math.acos(2 * Math.random() - 1);
          
          // æ·»åŠ éšæœºåç§»ä½¿å½¢çŠ¶ä¸è§„åˆ™
          const irregularity = 0.3;
          const x = radius * Math.sin(phi) * Math.cos(theta) * (1 + (Math.random() - 0.5) * irregularity);
          const y = radius * Math.sin(phi) * Math.sin(theta) * (1 + (Math.random() - 0.5) * irregularity);
          const z = radius * Math.cos(phi) * (1 + (Math.random() - 0.5) * irregularity);

          starPositions[i3] = x + params.position.x;
          starPositions[i3+1] = y + params.position.y;
          starPositions[i3+2] = z + params.position.z;

          // ä¸è§„åˆ™æ˜Ÿç³»é€šå¸¸æ›´è“ï¼ˆå¹´è½»æ’æ˜Ÿï¼‰
          starColors[i3] = 0.2 + Math.random() * 0.3;
          starColors[i3+1] = 0.4 + Math.random() * 0.3;
          starColors[i3+2] = 0.8 + Math.random() * 0.2;

          starSizes[i] = 0.05 + Math.random() * 0.2;

          stars.push({
            position: new THREE.Vector3(starPositions[i3], starPositions[i3+1], starPositions[i3+2]),
            distance: Math.sqrt(x*x + y*y),
            home: params.position,
            rotationAngle: galaxyRotation
          });
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 0.5
        });

        const starField = new THREE.Points(starGeometry, starMaterial);

        // ä¸è§„åˆ™æ˜Ÿç³»æœ‰æ›´å¤šå°˜åŸƒå’Œæ˜Ÿäº‘
        const dustField = this.createDustCloud({...params, count: universeParams.dustCount * 1.5});
        const nebulaField = this.createNebula({...params, count: universeParams.nebulaCount * 2});
        const halo = this.createHalo({...params, count: universeParams.haloCount * 0.5});

        return {
          position: params.position,
  starField,
  dustField,
  nebulaField,
  halo,
  stars,
  params,
  type: 'irregular'

        };
      },
// åˆ›å»ºç¢°æ’æ˜Ÿç³»
      createCollidingGalaxy(params) {
        // åˆ›å»ºä¸¤ä¸ªé è¿‘çš„æ˜Ÿç³»æ¨¡æ‹Ÿç¢°æ’
        const galaxy1 = this.createSpiralGalaxy({
          ...params,
          position: new THREE.Vector3(params.position.x - params.radius * 0.7, params.position.y, params.position.z),
          radius: params.radius * 0.8
        });
        
        const galaxy2 = this.createSpiralGalaxy({
          ...params,
          position: new THREE.Vector3(params.position.x + params.radius * 0.7, params.position.y, params.position.z),
          radius: params.radius * 0.6,
          rotationAngle: params.rotationAngle + Math.PI * 0.7 // ä¸åŒè§’åº¦
        });
        
        // åˆå¹¶ä¸¤ä¸ªæ˜Ÿç³»
        const mergedStars = [...galaxy1.stars, ...galaxy2.stars];
        
        // åˆ›å»ºè¿æ¥ä¸¤ä¸ªæ˜Ÿç³»çš„æ˜Ÿæµ
        const bridgeGeometry = new THREE.BufferGeometry();
        const bridgeCount = 500;
        const bridgePositions = new Float32Array(bridgeCount * 3);
        const bridgeColors = new Float32Array(bridgeCount * 3);
        const bridgeSizes = new Float32Array(bridgeCount);
        
        for (let i = 0; i < bridgeCount; i++) {
          const i3 = i * 3;
          const t = Math.random();
          const x = galaxy1.position.x * (1 - t) + galaxy2.position.x * t;
          const y = galaxy1.position.y * (1 - t) + galaxy2.position.y * t;
          const z = galaxy1.position.z * (1 - t) + galaxy2.position.z * t;
          
          // æ·»åŠ éšæœºåç§»
          const offset = 20;
          bridgePositions[i3] = x + (Math.random() - 0.5) * offset;
          bridgePositions[i3+1] = y + (Math.random() - 0.5) * offset;
          bridgePositions[i3+2] = z + (Math.random() - 0.5) * offset;
          
          bridgeColors[i3] = 0.6 + Math.random() * 0.2;
          bridgeColors[i3+1] = 0.4 + Math.random() * 0.2;
          bridgeColors[i3+2] = 0.2 + Math.random() * 0.1;
          
          bridgeSizes[i] = 0.05 + Math.random() * 0.1;
        }
        
        bridgeGeometry.setAttribute('position', new THREE.BufferAttribute(bridgePositions, 3));
        bridgeGeometry.setAttribute('color', new THREE.BufferAttribute(bridgeColors, 3));
        bridgeGeometry.setAttribute('size', new THREE.BufferAttribute(bridgeSizes, 1));
        
        const bridgeMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.7,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 0.5
        });
        
        const bridgeField = new THREE.Points(bridgeGeometry, bridgeMaterial);
        scene.add(bridgeField);
        
        return {
          position: params.position,
  starField: galaxy1.starField,
  dustField: galaxy1.dustField,
  nebulaField: galaxy1.nebulaField,
  halo: galaxy1.halo,
  stars: mergedStars,
  params,
  type: 'collision',
  galaxy2: galaxy2,
  bridgeField

        };
      },
      
      createDustCloud(params) {
        const count = params.count || universeParams.dustCount;
  const dustGeometry = new THREE.BufferGeometry();
  const dustPositions = new Float32Array(count * 3);
  const dustColors = new Float32Array(count * 3);
  const dustSizes = new Float32Array(count);

  // ä½¿ç”¨ä¼ å…¥çš„éšæœºæ–¹å‘
  const galaxyRotation = params.rotationAngle || 0;

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    const distance = Math.random() * params.radius * 0.9;
    const angle = Math.random() * Math.PI * 2 + galaxyRotation; // åº”ç”¨éšæœºæ–¹å‘
    const offset = (Math.random() - 0.5) * params.radius * 0.1;
    const height = (Math.random() - 0.5) * params.radius * 0.03;

    dustPositions[i3] = Math.cos(angle) * (distance + offset) + params.position.x;
    dustPositions[i3+1] = Math.sin(angle) * (distance + offset) + params.position.y;
    dustPositions[i3+2] = height + params.position.z;

    dustColors[i3] = 0.4 + Math.random() * 0.1;
    dustColors[i3+1] = 0.2 + Math.random() * 0.05;
    dustColors[i3+2] = 0.05 + Math.random() * 0.05;

    dustSizes[i] = 0.1 + Math.random() * 0.2;
  }



        const dustMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.7,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 1.0
        });

        return new THREE.Points(dustGeometry, dustMaterial);
      },
      
      createNebula(params) {
        const count = params.count || universeParams.nebulaCount;
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaPositions = new Float32Array(count * 3);
        const nebulaColors = new Float32Array(count * 3);
        const nebulaSizes = new Float32Array(count);

        const galaxyRotation = params.rotationAngle || 0;

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const distance = Math.random() * params.radius * 0.8;
          const angle = Math.random() * Math.PI * 2 + galaxyRotation;
          const offset = (Math.random() - 0.5) * params.radius * 0.2;
          const height = (Math.random() - 0.5) * params.radius * 0.05;

          nebulaPositions[i3] = Math.cos(angle) * (distance + offset) + params.position.x;
          nebulaPositions[i3+1] = Math.sin(angle) * (distance + offset) + params.position.y;
          nebulaPositions[i3+2] = height + params.position.z;

          // æ›´ä¸°å¯Œçš„æ˜Ÿäº‘é¢œè‰²
          const colorType = Math.random();
          if (colorType < 0.3) {
            // çº¢è‰²æ˜Ÿäº‘
            nebulaColors[i3] = 0.7 + Math.random() * 0.2;
            nebulaColors[i3+1] = 0.1 + Math.random() * 0.1;
            nebulaColors[i3+2] = 0.1 + Math.random() * 0.1;
          } else if (colorType < 0.6) {
            // è“è‰²æ˜Ÿäº‘
            nebulaColors[i3] = 0.1 + Math.random() * 0.1;
            nebulaColors[i3+1] = 0.3 + Math.random() * 0.2;
            nebulaColors[i3+2] = 0.7 + Math.random() * 0.2;
          } else {
            // ç´«è‰²æ˜Ÿäº‘
            nebulaColors[i3] = 0.5 + Math.random() * 0.2;
            nebulaColors[i3+1] = 0.2 + Math.random() * 0.1;
            nebulaColors[i3+2] = 0.6 + Math.random() * 0.2;
          }

          nebulaSizes[i] = 1.5 + Math.random() * 2.5;
        }

        nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
        nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
        nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));

        const nebulaMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.4,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 2.0
        });

        return new THREE.Points(nebulaGeometry, nebulaMaterial);
      },
      
      createHalo(params) {
        const count = params.count || universeParams.haloCount;
        const haloGeometry = new THREE.BufferGeometry();
        const haloPositions = new Float32Array(count * 3);
        const haloColors = new Float32Array(count * 3);
        const haloSizes = new Float32Array(count);

        const galaxyRotation = params.rotationAngle || 0;

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const radius = params.radius * (0.9 + Math.random() * 0.3);
          const theta = Math.random() * Math.PI * 2 + galaxyRotation;
          const phi = Math.acos(2 * Math.random() - 1);

          haloPositions[i3] = radius * Math.sin(phi) * Math.cos(theta) + params.position.x;
          haloPositions[i3+1] = radius * Math.sin(phi) * Math.sin(theta) + params.position.y;
          haloPositions[i3+2] = radius * Math.cos(phi) + params.position.z;

          haloColors[i3] = 0.1 + Math.random() * 0.05;
          haloColors[i3+1] = 0.2 + Math.random() * 0.1;
          haloColors[i3+2] = 0.4 + Math.random() * 0.1;

          haloSizes[i] = 0.05 + Math.random() * 0.1;
        }

        haloGeometry.setAttribute('position', new THREE.BufferAttribute(haloPositions, 3));
        haloGeometry.setAttribute('color', new THREE.BufferAttribute(haloColors, 3));
        haloGeometry.setAttribute('size', new THREE.BufferAttribute(haloSizes, 1));

        const haloMaterial = new THREE.PointsMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.3,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 1.0
        });

        return new THREE.Points(haloGeometry, haloMaterial);
      },
      
updateVisibleGalaxies() {
  const cameraPos = camera.position;
  let visibleCount = 0;
  
  // å…ˆç¡®ä¿æ‰€æœ‰æ˜Ÿç³»éƒ½åœ¨æ­£ç¡®çŠ¶æ€
  for (const galaxy of this.galaxies) {
    const absoluteDistance = galaxy.position.length();
    
    // è®¡ç®—è·ç¦»è¡°å‡å› å­
    let visibilityFactor = 1.0;
    let scaleFactor = 1.0;
    
    if (absoluteDistance <= universeParams.renderDistance) {
      visibilityFactor = 1.0;
      scaleFactor = 1.0;
      visibleCount++;
    } else {
      const excessDistance = absoluteDistance - universeParams.renderDistance;
      const maxFadeDistance = universeParams.renderDistance * 0.5;
      
      if (excessDistance <= maxFadeDistance) {
        visibilityFactor = 1.0 - (excessDistance / maxFadeDistance);
        scaleFactor = 0.1 + (visibilityFactor * 0.9);
        visibleCount++;
      } else {
        visibilityFactor = 0.1;
        scaleFactor = 0.05;
      }
    }
    
    this.updateGalaxyAppearance(galaxy, visibilityFactor, scaleFactor);
    
    // ç¡®ä¿æ‰€æœ‰æ˜Ÿç³»éƒ½åœ¨åœºæ™¯ä¸­
    if (!scene.children.includes(galaxy.starField)) {
      this.addGalaxyToScene(galaxy);
    }
  }
  
  document.getElementById('visibleGalaxies').textContent = visibleCount;
  
  // æ— é™ç”Ÿæˆé€»è¾‘ï¼šå§‹ç»ˆç”Ÿæˆæ–°æ˜Ÿç³»
  const volume = (4/3) * Math.PI * Math.pow(universeParams.renderDistance, 3);
  const targetCount = Math.floor(volume * universeParams.galaxyDensity * universeParams.densityMultiplier);
  const currentCount = this.galaxies.length;
  
  // å¦‚æœå½“å‰æ˜Ÿç³»æ•°é‡å°‘äºç›®æ ‡æ•°é‡ï¼Œå°±ç”Ÿæˆæ–°çš„
  if (currentCount < targetCount && currentCount < universeParams.maxVisible) {
    const needed = Math.min(5, targetCount - currentCount); // æ¯æ¬¡æœ€å¤šç”Ÿæˆ5ä¸ª
    
    for (let i = 0; i < needed; i++) {
      this.createAndAddGalaxy(cameraPos);
    }
  }
  
  document.getElementById('galaxyCount').textContent = `æ˜Ÿç³»: ${this.galaxies.length}`;
},
      
      createAndAddGalaxy(nearPosition) {
  let position;
  let attempts = 0;
  
  do {
    const angle1 = Math.random() * Math.PI * 2;
    const angle2 = Math.random() * Math.PI * 2;
    const distance = Math.random() * universeParams.renderDistance * 1.5 + universeParams.minDistance;
    
    position = new THREE.Vector3(
      Math.cos(angle1) * Math.sin(angle2) * distance,
      Math.sin(angle1) * Math.sin(angle2) * distance,
      Math.cos(angle2) * distance
    );
    
    attempts++;
    if (attempts >= 100) break;
  } while (
    this.galaxies.some(g => g.position.distanceTo(position) < universeParams.minDistance)
  );
  
  const radius = 25 + Math.random() * 35;
  const arms = Math.floor(Math.random() * 3) + 2;
  const armTwist = 0.15 + Math.random() * 0.1;
  const rotationSpeed = 0.001 + Math.random() * 0.001;
  
  // ç”Ÿæˆå®Œå…¨éšæœºçš„ä¸‰ç»´æœå‘
  const randomQuaternion = new THREE.Quaternion();
  randomQuaternion.setFromUnitVectors(
    new THREE.Vector3(0, 0, 1), // é»˜è®¤æœå‘ (Zè½´æ­£æ–¹å‘)
    new THREE.Vector3(
      Math.random() * 2 - 1,
      Math.random() * 2 - 1, 
      Math.random() * 2 - 1
    ).normalize() // éšæœºæ–¹å‘å‘é‡
  );
  
  // æˆ–è€…ä½¿ç”¨æ¬§æ‹‰è§’æ–¹æ³•ï¼ˆæ›´ç®€å•ï¼‰
  const randomEuler = new THREE.Euler(
    Math.random() * Math.PI * 2,  // xè½´æ—‹è½¬
    Math.random() * Math.PI * 2,  // yè½´æ—‹è½¬  
    Math.random() * Math.PI * 2   // zè½´æ—‹è½¬
  );
  const orientation = new THREE.Quaternion().setFromEuler(randomEuler);
  
  console.log(`åˆ›å»ºæ–°æ˜Ÿç³»ï¼Œéšæœºä¸‰ç»´æœå‘`);
  
  // æŒ‰çœŸå®å®‡å®™æ¯”ä¾‹éšæœºé€‰æ‹©æ˜Ÿç³»ç±»å‹
  const rand = Math.random();
  let type;
  if (rand < 0.77) {
    type = 'spiral';
  } else if (rand < 0.97) {
    type = 'elliptical';
  } else if (rand < 0.999) {
    type = 'irregular';
  } else {
    type = 'collision';
  }
  
  const params = {
    position,
    radius,
    arms,
    armTwist,
    rotationSpeed,
    orientation,  // ä½¿ç”¨ä¸‰ç»´æœå‘è€Œä¸æ˜¯äºŒç»´è§’åº¦
    type: type
  };
  
  const galaxy = this.createGalaxyByType(params);
  this.galaxies.push(galaxy);

  
  // ç›´æ¥æ·»åŠ åˆ°åœºæ™¯
  scene.add(galaxy.starField);
  scene.add(galaxy.dustField);
  scene.add(galaxy.nebulaField);
  scene.add(galaxy.halo);
  
  // å¦‚æœæ˜¯ç¢°æ’æ˜Ÿç³»ï¼Œæ·»åŠ ç¬¬äºŒä¸ªæ˜Ÿç³»å’Œæ¡¥æ¥
  if (galaxy.type === 'collision' && galaxy.galaxy2) {
    scene.add(galaxy.galaxy2.starField);
    scene.add(galaxy.galaxy2.dustField);
    scene.add(galaxy.galaxy2.nebulaField);
    scene.add(galaxy.galaxy2.halo);
    scene.add(galaxy.bridgeField);
  }
  
  return galaxy;
},
      
      updateRotations(speed) {
        const now = Date.now();
        if (now - this.lastUpdate < this.updateInterval) return;
        
        for (const galaxy of this.galaxies) {
          const distance = galaxy.position.distanceTo(camera.position);
          if (distance <= universeParams.renderDistance) {
            this.updateGalaxy(galaxy, speed);
            
            // å¦‚æœæ˜¯ç¢°æ’æ˜Ÿç³»ï¼Œæ›´æ–°ç¬¬äºŒä¸ªæ˜Ÿç³»
            if (galaxy.type === 'collision' && galaxy.galaxy2) {
              this.updateGalaxy(galaxy.galaxy2, speed);
              
              // æ›´æ–°æ¡¥æ¥
              this.updateGalaxyBridge(galaxy, speed);
            }
          }
        }
        
        this.lastUpdate = now;
      },
      // æ›´æ–°æ˜Ÿç³»å¤–è§‚ï¼ˆé€æ˜åº¦å’Œç¼©æ”¾ï¼‰
// æ›´æ–°æ˜Ÿç³»å¤–è§‚ï¼ˆåŸºäºè·ç¦»çš„è§†è§‰æ•ˆæœï¼‰
updateGalaxyAppearance(galaxy, visibility, scale) {
  // æ’æ˜Ÿåœº - æœ€æ˜æ˜¾çš„éƒ¨åˆ†
  galaxy.starField.material.opacity = visibility;
  galaxy.starField.scale.set(scale, scale, scale);
  
  // å°˜åŸƒäº‘ - æ¯”æ’æ˜Ÿæ›´å¿«è¡°å‡
  const dustVisibility = Math.max(0, visibility - 0.3);
  galaxy.dustField.material.opacity = dustVisibility;
  galaxy.dustField.scale.set(scale * 0.8, scale * 0.8, scale * 0.8);
  
  // æ˜Ÿäº‘ - æ›´å¿«è¡°å‡
  const nebulaVisibility = Math.max(0, visibility - 0.5);
  galaxy.nebulaField.material.opacity = nebulaVisibility;
  galaxy.nebulaField.scale.set(scale * 0.6, scale * 0.6, scale * 0.6);
  
  // å…‰æ™• - æœ€å¿«è¡°å‡
  const haloVisibility = Math.max(0, visibility - 0.7);
  galaxy.halo.material.opacity = haloVisibility;
  galaxy.halo.scale.set(scale * 0.4, scale * 0.4, scale * 0.4);
  
  // å¦‚æœæ˜¯ç¢°æ’æ˜Ÿç³»ï¼Œæ›´æ–°ç¬¬äºŒä¸ªæ˜Ÿç³»
  if (galaxy.type === 'collision' && galaxy.galaxy2) {
    galaxy.galaxy2.starField.material.opacity = visibility;
    galaxy.galaxy2.starField.scale.set(scale, scale, scale);
    
    galaxy.galaxy2.dustField.material.opacity = dustVisibility;
    galaxy.galaxy2.dustField.scale.set(scale * 0.8, scale * 0.8, scale * 0.8);
    
    galaxy.galaxy2.nebulaField.material.opacity = nebulaVisibility;
    galaxy.galaxy2.nebulaField.scale.set(scale * 0.6, scale * 0.6, scale * 0.6);
    
    galaxy.galaxy2.halo.material.opacity = haloVisibility;
    galaxy.galaxy2.halo.scale.set(scale * 0.4, scale * 0.4, scale * 0.4);
    
    if (galaxy.bridgeField) {
      galaxy.bridgeField.material.opacity = visibility * 0.5;
      galaxy.bridgeField.scale.set(scale, scale, scale);
    }
  }
},

// æ·»åŠ æ˜Ÿç³»åˆ°åœºæ™¯
addGalaxyToScene(galaxy) {
  scene.add(galaxy.starField);
  scene.add(galaxy.dustField);
  scene.add(galaxy.nebulaField);
  scene.add(galaxy.halo);
  
  if (galaxy.type === 'collision' && galaxy.galaxy2) {
    scene.add(galaxy.galaxy2.starField);
    scene.add(galaxy.galaxy2.dustField);
    scene.add(galaxy.galaxy2.nebulaField);
    scene.add(galaxy.galaxy2.halo);
    if (galaxy.bridgeField) scene.add(galaxy.bridgeField);
  }
},

// ä»åœºæ™¯ç§»é™¤æ˜Ÿç³»
removeGalaxyFromScene(galaxy) {
  scene.remove(galaxy.starField);
  scene.remove(galaxy.dustField);
  scene.remove(galaxy.nebulaField);
  scene.remove(galaxy.halo);
  
  if (galaxy.type === 'collision' && galaxy.galaxy2) {
    scene.remove(galaxy.galaxy2.starField);
    scene.remove(galaxy.galaxy2.dustField);
    scene.remove(galaxy.galaxy2.nebulaField);
    scene.remove(galaxy.galaxy2.halo);
    if (galaxy.bridgeField) scene.remove(galaxy.bridgeField);
  }
},
      updateGalaxy(galaxy, speed) {
        const positions = galaxy.starField.geometry.attributes.position.array;
        
        for (let i = 0; i < galaxy.stars.length; i++) {
          const i3 = i * 3;
          const star = galaxy.stars[i];
          
          // è®¡ç®—æ–°è§’åº¦
          const baseAngle = Math.atan2(star.position.y - star.home.y, star.position.x - star.home.x) - star.rotationAngle;
          const newAngle = baseAngle + galaxy.params.rotationSpeed * speed + star.rotationAngle;
          
          let newDistance = star.distance;
          switch(star.type) {
            case 0: // æ ¸å¿ƒ
              newDistance += 0.0005 * speed;
              break;
            case 1: // æ—‹è‡‚
              newDistance += (Math.random() - 0.5) * 0.003 * speed;
              break;
            case 2: // å…‰æ™•
              newDistance -= 0.0003 * speed;
              break;
            case 3: // çƒçŠ¶æ˜Ÿå›¢
              newDistance += (Math.random() - 0.5) * 0.001 * speed;
              break;
            default: // æ¤­åœ†æˆ–ä¸è§„åˆ™æ˜Ÿç³»
              newDistance += (Math.random() - 0.5) * 0.002 * speed;
          }
          
          positions[i3] = Math.cos(newAngle) * newDistance + star.home.x;
          positions[i3+1] = Math.sin(newAngle) * newDistance + star.home.y;
          
          // æ¤­åœ†æ˜Ÿç³»åœ¨Zè½´æ–¹å‘è¿åŠ¨è¾ƒå°
          if (galaxy.type === 'elliptical') {
            positions[i3+2] += (Math.random() - 0.5) * 0.001 * speed;
          } else {
            positions[i3+2] += (Math.random() - 0.5) * 0.005 * speed;
          }
          
          star.position.set(positions[i3], positions[i3+1], positions[i3+2]);
          star.distance = newDistance;
        }
        
        galaxy.starField.geometry.attributes.position.needsUpdate = true;
        
        // æ›´æ–°å°˜åŸƒäº‘
        const dustPositions = galaxy.dustField.geometry.attributes.position.array;
        for (let i = 0; i < dustPositions.length; i += 3) {
          const x = dustPositions[i] - galaxy.params.position.x;
          const y = dustPositions[i+1] - galaxy.params.position.y;
          const baseAngle = Math.atan2(y, x) - galaxy.params.rotationAngle;
          const newAngle = baseAngle + galaxy.params.rotationSpeed * speed + galaxy.params.rotationAngle;
          const distance = Math.sqrt(x * x + y * y);
          
          dustPositions[i] = Math.cos(newAngle) * distance + galaxy.params.position.x;
          dustPositions[i+1] = Math.sin(newAngle) * distance + galaxy.params.position.y;
        }
        galaxy.dustField.geometry.attributes.position.needsUpdate = true;
        
        // æ›´æ–°æ˜Ÿäº‘
        const nebulaPositions = galaxy.nebulaField.geometry.attributes.position.array;
        for (let i = 0; i < nebulaPositions.length; i += 3) {
          const x = nebulaPositions[i] - galaxy.params.position.x;
          const y = nebulaPositions[i+1] - galaxy.params.position.y;
          const baseAngle = Math.atan2(y, x) - galaxy.params.rotationAngle;
          const newAngle = baseAngle + galaxy.params.rotationSpeed * speed + galaxy.params.rotationAngle;
          const distance = Math.sqrt(x * x + y * y);
          
          nebulaPositions[i] = Math.cos(newAngle) * distance + galaxy.params.position.x;
          nebulaPositions[i+1] = Math.sin(newAngle) * distance + galaxy.params.position.y;
        }
        galaxy.nebulaField.geometry.attributes.position.needsUpdate = true;
        
        // æ›´æ–°å…‰æ™•
        const haloPositions = galaxy.halo.geometry.attributes.position.array;
        for (let i = 0; i < haloPositions.length; i += 3) {
          const x = haloPositions[i] - galaxy.params.position.x;
          const y = haloPositions[i+1] - galaxy.params.position.y;
          const baseAngle = Math.atan2(y, x) - galaxy.params.rotationAngle;
          const newAngle = baseAngle + galaxy.params.rotationSpeed * speed + galaxy.params.rotationAngle;
          const distance = Math.sqrt(x * x + y * y);
          
          haloPositions[i] = Math.cos(newAngle) * distance + galaxy.params.position.x;
          haloPositions[i+1] = Math.sin(newAngle) * distance + galaxy.params.position.y;
        }
        galaxy.halo.geometry.attributes.position.needsUpdate = true;
      },
      
      updateGalaxyBridge(galaxy, speed) {
        if (!galaxy.bridgeField) return;
        
        const positions = galaxy.bridgeField.geometry.attributes.position.array;
        
        // ç®€å•åœ°åœ¨ä¸¤ä¸ªæ˜Ÿç³»ä¹‹é—´ç§»åŠ¨æ¡¥æ¥ç²’å­
        for (let i = 0; i < positions.length; i += 3) {
          const t = (Math.sin(Date.now() * 0.001 + i * 0.01) + 1) * 0.5;
          const x = galaxy.position.x * (1 - t) + galaxy.galaxy2.position.x * t;
          const y = galaxy.position.y * (1 - t) + galaxy.galaxy2.position.y * t;
          const z = galaxy.position.z * (1 - t) + galaxy.galaxy2.position.z * t;
          
          const offset = 20;
          positions[i] = x + (Math.random() - 0.5) * offset;
          positions[i+1] = y + (Math.random() - 0.5) * offset;
          positions[i+2] = z + (Math.random() - 0.5) * offset;
        }
        
        galaxy.bridgeField.geometry.attributes.position.needsUpdate = true;
      },
      
      clearAllGalaxies() {
        for (const galaxy of this.galaxies) {
          scene.remove(galaxy.starField);
          scene.remove(galaxy.dustField);
          scene.remove(galaxy.nebulaField);
          scene.remove(galaxy.halo);
          
          if (galaxy.type === 'collision' && galaxy.galaxy2) {
            scene.remove(galaxy.galaxy2.starField);
            scene.remove(galaxy.galaxy2.dustField);
            scene.remove(galaxy.galaxy2.nebulaField);
            scene.remove(galaxy.galaxy2.halo);
            scene.remove(galaxy.bridgeField);
          }
        }
        
        this.galaxies = [];
      }
    };

    // åæœŸå¤„ç†
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8,
      0.4,
      0.7
    );
    composer.addPass(bloomPass);
    
    const luminosityPass = new THREE.ShaderPass(THREE.LuminosityHighPassShader);
    luminosityPass.material.uniforms['luminosityThreshold'].value = 0.05;
    luminosityPass.material.uniforms['smoothWidth'].value = 0.1;
    composer.addPass(luminosityPass);
    // éŸ³ä¹ç®¡ç†å™¨
// éŸ³ä¹ç®¡ç†å™¨ - å•éŸ³ä¹ç‰ˆæœ¬
const musicManager = {
  audioElement: null,
  isPlaying: false,
  volume: 0.5,
  
  // åªæœ‰ä¸€é¦–éŸ³ä¹
  musicUrls: [
    'https://raw.githubusercontent.com/anlpi/cosmic/main/å”¤é†’å¤§è„‘ - é˜¿å°”æ³•è„‘æ³¢éŸ³ä¹.mp3'  // æ›¿æ¢ä¸ºä½ çš„éŸ³ä¹æ–‡ä»¶å
  ],
  currentTrack: 0,
  
  init() {
    this.audioElement = new Audio();
    this.audioElement.volume = this.volume;
    this.audioElement.loop = true;  // å•æ›²å¾ªç¯
    this.audioElement.src = this.musicUrls[0];
    
    // é¢„åŠ è½½
    this.audioElement.load();
    
    // ç›‘å¬åŠ è½½é”™è¯¯
    this.audioElement.addEventListener('error', (e) => {
      console.error('éŸ³ä¹åŠ è½½å¤±è´¥:', e);
      const button = document.getElementById('musicToggle');
      button.innerHTML = '<span class="mr-2">âŒ</span> åŠ è½½å¤±è´¥';
      button.classList.add('bg-red-600');
      button.title = 'éŸ³ä¹æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„';
    });
    
    // ç›‘å¬åŠ è½½æˆåŠŸ
    this.audioElement.addEventListener('canplaythrough', () => {
      console.log('éŸ³ä¹åŠ è½½æˆåŠŸï¼Œå¯ä»¥æ’­æ”¾');
    });
  },
  
  toggleMusic() {
    if (this.isPlaying) {
      this.stopMusic();
    } else {
      this.startMusic();
    }
  },
  
  startMusic() {
    if (!this.audioElement) {
      this.init();
    }
    
    this.audioElement.play().then(() => {
      this.isPlaying = true;
      updateMusicButton();
      console.log('éŸ³ä¹å¼€å§‹æ’­æ”¾');
    }).catch(error => {
      console.warn('éŸ³ä¹æ’­æ”¾å¤±è´¥:', error);
      // æ˜¾ç¤ºå‹å¥½çš„æç¤º
      const button = document.getElementById('musicToggle');
      button.innerHTML = '<span class="mr-2">â¸ï¸</span> ç‚¹å‡»æ’­æ”¾';
      button.title = 'ç‚¹å‡»å¼€å§‹æ’­æ”¾éŸ³ä¹';
    });
  },
  
  stopMusic() {
    if (this.audioElement) {
      this.audioElement.pause();
      this.audioElement.currentTime = 0;
    }
    this.isPlaying = false;
    updateMusicButton();
    console.log('éŸ³ä¹åœæ­¢');
  },
  
  setVolume(volume) {
    this.volume = volume;
    if (this.audioElement) {
      this.audioElement.volume = volume;
    }
    document.getElementById('volumeValue').textContent = `${Math.round(volume * 100)}%`;
    console.log('éŸ³é‡è®¾ç½®ä¸º:', volume);
  },
  
  nextTrack() {
    // å•éŸ³ä¹ç‰ˆæœ¬ä¸éœ€è¦åˆ‡æ¢
    console.log('åªæœ‰ä¸€é¦–éŸ³ä¹ï¼Œä¸åˆ‡æ¢');
  }
};

    // åŠ¨ç”»æ§åˆ¶
    let isRunning = false;
    let animationId;
    let speed = 1.0;
    let lastTime = 0;
    let fps = 60;

    const speedSlider = document.getElementById('speedSlider');
    speedSlider.addEventListener('input', (e) => {
      speed = parseFloat(e.target.value);
      document.getElementById('speedValue').textContent = `${speed.toFixed(1)}x`;
    });
    // é€Ÿåº¦æ§åˆ¶äº‹ä»¶ï¼ˆåŸæœ‰çš„ï¼‰

// === åœ¨è¿™é‡Œæ·»åŠ éŸ³ä¹æ§åˆ¶äº‹ä»¶ ===
// éŸ³ä¹æ§åˆ¶
document.getElementById('musicToggle').addEventListener('click', () => {
  musicManager.toggleMusic();
  updateMusicButton();
});

document.getElementById('volumeSlider').addEventListener('input', (e) => {
  const volume = parseFloat(e.target.value);
  musicManager.setVolume(volume);
  document.getElementById('volumeValue').textContent = `${Math.round(volume * 100)}%`;
});

// æ›´æ–°éŸ³ä¹æŒ‰é’®çŠ¶æ€
function updateMusicButton() {
  const button = document.getElementById('musicToggle');
  if (musicManager.isPlaying) {
    button.innerHTML = '<span class="mr-2">ğŸ”Š</span> éŸ³ä¹';
    button.classList.remove('bg-purple-600');
    button.classList.add('bg-green-600');
  } else {
    button.innerHTML = '<span class="mr-2">ğŸ”‡</span> éŸ³ä¹';
    button.classList.remove('bg-green-600');
    button.classList.add('bg-purple-600');
  }
}
// === éŸ³ä¹æ§åˆ¶äº‹ä»¶ç»“æŸ ===
// === UIéšè—/æ˜¾ç¤ºåŠŸèƒ½ ===
document.getElementById('hideUI').addEventListener('click', function() {
    document.body.classList.add('ui-hidden');
    this.innerHTML = 'æ˜¾ç¤ºUI';
});

document.getElementById('showUI').addEventListener('click', function() {
    document.body.classList.remove('ui-hidden');
    this.style.display = 'none';
    document.getElementById('hideUI').innerHTML = 'éšè—UI';
});

// === é¼ æ ‡ç§»åŠ¨æ˜¾ç¤ºUIæŒ‰é’® ===
let hideTimer = null;

document.addEventListener('mousemove', () => {
    const showUI = document.getElementById('showUI');
    
    // åªæœ‰åœ¨UIéšè—æ—¶æ‰å¤„ç†
    if (document.body.classList.contains('ui-hidden')) {
        // ç«‹å³æ˜¾ç¤ºï¼ˆæ— è¿‡æ¸¡ï¼‰
        showUI.style.display = 'block';
        showUI.classList.add('visible');
        
        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
        if (hideTimer) {
            clearTimeout(hideTimer);
        }
        
        // 1ç§’åå¼€å§‹æ·¡å‡º
        hideTimer = setTimeout(() => {
            showUI.classList.remove('visible');
            // æ·¡å‡ºå®Œæˆåéšè—
            setTimeout(() => {
                showUI.style.display = 'none';
            }, 1000);
        }, 1000);
    }
});
// === UIåŠŸèƒ½ç»“æŸ ===
// æ˜Ÿç³»ç±»å‹é€‰æ‹©ï¼ˆå¦‚æœè¿˜æœ‰çš„è¯ï¼‰...

    const densitySlider = document.getElementById('densitySlider');
    densitySlider.addEventListener('input', (e) => {
      universeParams.densityMultiplier = parseFloat(e.target.value);
      document.getElementById('densityValue').textContent = `${universeParams.densityMultiplier.toFixed(1)}x`;
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      if (!isRunning) {
        isRunning = true;
        animate();
      }
    });

    document.getElementById('pauseBtn').addEventListener('click', () => {
      isRunning = false;
      cancelAnimationFrame(animationId);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      galaxyManager.clearAllGalaxies();
      galaxyManager.init();
      freeMoveController.resetCamera();
    });

 

    // ä¸»åŠ¨ç”»å¾ªç¯
    function animate() {
  if (!isRunning) return;
  
  animationId = requestAnimationFrame(animate);
  
  // è®¡ç®—FPS
  const now = performance.now();
  if (lastTime) {
    fps = Math.round(1000 / (now - lastTime));
    document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
  }
  lastTime = now;
  
  // æ›´æ–°è‡ªç”±ç§»åŠ¨
  freeMoveController.update();
  
  // æ¯5å¸§æ›´æ–°ä¸€æ¬¡æ˜Ÿç³»å¯è§æ€§ï¼ˆæå‡æ€§èƒ½ï¼‰
  if (frameCount % 5 === 0) {
    galaxyManager.updateVisibleGalaxies();
  }
  
  frameCount++;
  galaxySelectionSystem.update();
  
  composer.render();
}

let frameCount = 0; // æ·»åŠ å¸§è®¡æ•°å™¨

    // å“åº”çª—å£resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
composer.setSize(window.innerWidth, window.innerHeight);
    });

    // åˆå§‹åŒ–
function init() {
  // æ¨¡æ‹ŸåŠ è½½è¿‡ç¨‹
  let progress = 0;
  const loadingInterval = setInterval(() => {
    progress += Math.random() * 10;
    if (progress >= 100) {
      progress = 100;
      clearInterval(loadingInterval);
      
      // éšè—åŠ è½½å±å¹•ï¼Œæ˜¾ç¤ºä¸»å†…å®¹
      document.getElementById('loadingScreen').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('mainContent').classList.remove('hidden');
        
        // å¼€å§‹åŠ¨ç”»
        animate();
      }, 1000);
    }
    document.getElementById('loadingProgress').style.width = `${progress}%`;
  }, 100);
  
  // åˆå§‹åŒ–ç³»ç»Ÿ
  
  freeMoveController.init();
   galaxySelectionSystem.init();
  createBackgroundStars();
  
  galaxyManager.init();
  
  
  // è®¾ç½®åˆå§‹ç›¸æœºä½ç½®å’Œæœå‘
  camera.position.set(390, 500, 0);
  camera.lookAt(camera.position.clone().add(freeMoveController.cameraDirection));
  
  // åˆå§‹åŒ–é€Ÿåº¦æ˜¾ç¤º
  freeMoveController.updateSpeedDisplay();
  
  // === åœ¨è¿™é‡Œæ·»åŠ éŸ³ä¹è‡ªåŠ¨æ’­æ”¾ ===
  // åˆå§‹åŒ–éŸ³ä¹ï¼ˆç”¨æˆ·äº¤äº’åè‡ªåŠ¨æ’­æ”¾ï¼‰
  document.addEventListener('click', function initMusic() {
    musicManager.startMusic();
    updateMusicButton();
    document.removeEventListener('click', initMusic);
  }, { once: true });
  // === éŸ³ä¹åˆå§‹åŒ–ç»“æŸ ===
  
  // åˆå§‹æ¸²æŸ“
  composer.render();
}

// å¼€å§‹åˆå§‹åŒ–
init();
  </script>
</body>
</html>
